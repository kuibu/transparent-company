#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import os
import subprocess
import sys
from pathlib import Path
from urllib.parse import urlencode
from urllib.request import Request, urlopen

REPO_ROOT = Path(__file__).resolve().parents[1]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

RUNTIME_IMPORT_ERROR: Exception | None = None
try:
    from app.disclosure.commitment import normalize_group_param
    from app.ledger.canonical import canonical_json
    from app.ledger.merkle import MerkleTree, hash_leaf_payload, verify_proof
    from app.ledger.signing import load_role_key, verify_object
except ModuleNotFoundError as exc:  # pragma: no cover - host fallback path
    RUNTIME_IMPORT_ERROR = exc


def _delegate_to_app_container() -> None:
    cmd = [
        "docker",
        "compose",
        "exec",
        "-T",
        "app",
        "env",
        "TC_VERIFY_IN_APP_CONTAINER=1",
        "python",
        "/workspace/scripts/verify_disclosure.py",
        *sys.argv[1:],
    ]
    proc = subprocess.run(cmd, cwd=str(REPO_ROOT))
    raise SystemExit(proc.returncode)


def _ensure_runtime_deps() -> None:
    if RUNTIME_IMPORT_ERROR is None:
        return

    if os.getenv("TC_VERIFY_IN_APP_CONTAINER") == "1":
        raise RuntimeError(f"missing Python dependency in app container: {RUNTIME_IMPORT_ERROR}")

    # Host fallback: if local Python lacks project deps, run verification inside app container.
    try:
        subprocess.run(["docker", "compose", "version"], cwd=str(REPO_ROOT), check=True, capture_output=True)
    except Exception as exc:  # pragma: no cover
        raise RuntimeError(
            f"missing local Python dependency ({RUNTIME_IMPORT_ERROR}) and docker compose unavailable ({exc})"
        ) from exc

    _delegate_to_app_container()


def _http_get_json(url: str, params: dict | None = None, timeout: int = 30) -> dict:
    full_url = url
    if params:
        query = urlencode(params)
        connector = "&" if "?" in url else "?"
        full_url = f"{url}{connector}{query}"

    req = Request(full_url, method="GET")
    with urlopen(req, timeout=timeout) as resp:
        status = getattr(resp, "status", 200)
        body = resp.read().decode("utf-8")

    if int(status) >= 400:
        raise RuntimeError(f"HTTP {status} for {full_url}: {body}")
    return json.loads(body)


def _sort_key(payload: dict) -> tuple:
    return (
        payload["metric_key"],
        canonical_json(payload["group"]).decode("utf-8"),
        payload["period"]["start"],
        payload["period"]["end"],
    )


def recompute_summary_root(statement: dict) -> str:
    committed_leafs = statement.get("commitments", {}).get("leaf_payloads") or []
    if committed_leafs:
        sorted_leafs = sorted(committed_leafs, key=_sort_key)
        return MerkleTree([hash_leaf_payload(payload) for payload in sorted_leafs]).root

    period = statement["period"]
    policy_id = statement["policy_id"]
    policy_hash = statement["policy_hash"]

    leaves = []
    for metric_key, value in statement.get("metrics", {}).items():
        leaves.append(
            {
                "metric_key": metric_key,
                "group": {},
                "period": period,
                "value": int(value),
                "policy_id": policy_id,
                "policy_hash": policy_hash,
            }
        )
    for row in statement.get("grouped_metrics", []):
        payload = {
            "metric_key": row["metric_key"],
            "group": row.get("group", {}),
            "period": period,
            "value": int(row["value"]),
            "policy_id": policy_id,
            "policy_hash": policy_hash,
        }
        if "detail_root" in row:
            payload["detail_root"] = row["detail_root"]
        leaves.append(payload)

    leaves.sort(key=_sort_key)
    hashes = [hash_leaf_payload(payload) for payload in leaves]
    return MerkleTree(hashes).root


def _resolve_public_key(disclosure_data: dict, statement: dict, cli_public_key: str) -> tuple[str, str]:
    if cli_public_key:
        return cli_public_key, "cli"

    stmt_signer = (statement or {}).get("signer", {})
    if isinstance(stmt_signer, dict) and stmt_signer.get("public_key_b64"):
        return stmt_signer["public_key_b64"], "statement.signer"

    if disclosure_data.get("signer_public_key"):
        return disclosure_data["signer_public_key"], "disclosure.signer_public_key"

    # Backward-compatible fallback for old disclosures generated by agent signer.
    return load_role_key("agent").public_key_b64, "fallback.agent"


def main() -> None:
    _ensure_runtime_deps()

    parser = argparse.ArgumentParser(description="Verify disclosure signature, Merkle root, and proof")
    parser.add_argument("--base-url", default="http://localhost:8000")
    parser.add_argument("--disclosure-id", required=True)
    parser.add_argument("--metric-key", required=True)
    parser.add_argument("--group", default="{}", help="JSON object or k=v,k2=v2")
    parser.add_argument("--public-key", default="", help="Ed25519 public key (base64)")
    args = parser.parse_args()

    disclosure_data = _http_get_json(f"{args.base_url}/disclosure/{args.disclosure_id}")

    statement = disclosure_data["statement"]
    signature = disclosure_data["statement_signature"]
    public_key, key_source = _resolve_public_key(disclosure_data, statement, args.public_key)

    sig_ok = verify_object(statement, signature, public_key)
    recomputed_root = recompute_summary_root(statement)
    stated_root = statement["commitments"]["root_summary"]

    group = normalize_group_param(args.group)
    proof_resp = _http_get_json(
        f"{args.base_url}/disclosure/{args.disclosure_id}/proof",
        params={"metric_key": args.metric_key, "group": json.dumps(group, ensure_ascii=False)},
    )
    proof_data = proof_resp["proof"]

    leaf_hash = proof_data["leaf_hash"]
    proof_ok = verify_proof(leaf_hash, proof_data["proof"], proof_data["root_summary"])

    print(
        json.dumps(
            {
                "disclosure_id": args.disclosure_id,
                "signature_valid": sig_ok,
                "public_key_source": key_source,
                "stated_root": stated_root,
                "recomputed_root": recomputed_root,
                "root_match": stated_root == recomputed_root,
                "proof_valid": proof_ok,
                "metric_key": args.metric_key,
                "group": group,
            },
            indent=2,
            ensure_ascii=False,
        )
    )

    if not (sig_ok and proof_ok and stated_root == recomputed_root):
        raise SystemExit(1)


if __name__ == "__main__":
    main()
